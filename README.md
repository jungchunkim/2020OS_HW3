# SFS 파일 시스템

## 개요

현존하는 파일 시스템을 간략화 시킨 Simple File System(SFS)의 구현을 통한
파일시스템의 이해를 높이는 것을 목적으로 합니다. SFS는 실제 디스크를 사용 하는 것이 아닌, 파일을
통해 디스크를 시뮬레이션 하는 형태로 동작하는데, 과제에서는 주어진 디스크 이미지 파일을 사용하여
SFS와 관련된 명령어들을 구현하게 됩니다.


## Simple File System

본 과제에서는 실제 디스크를 사용 하는 것이  아닌, 디스크와  동등한  형태의  디스크 이미지 파일을
사용 하여 과제를 진행합니다.(파일 DISK1.img, DISK2.img, DISKFull.img) 이들 이미지들은 SFS에서
사용하는 레이아웃 형태로 포맷되어 있는데,disk_read(),disk_write() 함수를 통하여 실제 디스크와 같이
블록단위로 엑세스하게 됩니다. 파일시스템은 디스크의 가용한 블록(free blocks)들을 관리 하거나, 파일시스템 내 실제 파일을 관리 하기 위해 많은 방법들을 사용하는데, FAT이나 i-node와 같은 방법이
이에 해당합니다.SFS에서는 디렉토리 구조나 파일을 관리하기 위해 i-node를 사용하고, 가용한 블록(free blocks)들을 관리하기 위하여 비트맵 형태의 사용합니다

## 명령어 설명

- ### mount disk_image_file_name
mount 명령어는 디스크 파일 이미지를 사용하고자 할 때 사용하는 명령어입니다. 다른 명령어를
사용하기 전에 mount가 선행되어야 합니다. mount 명령어에서는 슈퍼블록을 읽고 매직넘버 등을
확인하는 작업을 수행합니다.

- ### umount
umount 명령어는 사용하던 디스크 파일 close하고 슈퍼블록과 current working directory 구조체
(spb, sd_cwd)를 초기화하여 다음 mount 명령어를 사용 할 수 있도록 하여 줍니다. (umount
명령어는 제공 되므로 사용만 하면 됩니다.)

- ### dump
dump 명령어는 현재 디렉토리(currentworkingdirectory)의 정보 – 디렉토리 i-node 정보, 디렉토리
엔트리 정보, 디렉토리 엔트리의 대상이 파일인 경우 파일 i-node의 정보를 출력합니다. (dump
명령어는 예제로 제공되므로 다른 명령어 구현 및 디버깅 시 사용하기 바랍니다.)

- ### ls [path]
path로 명시된 디렉토리 내의 파일과 디렉토리의 이름을 출력하는 명령어입니다. 이 때 파일과 디
렉토리의 구분을 위하여 디렉토리 이름 뒤에는 / 를 함께 붙어서 출력해야 합니다.path가 없으면
현재 디렉토리를 의미 하며 path가 파일이면 해당 파일 이름을 출력합니다. 에러 상황으로는
path에 해당하는 디렉토리나 파일이 없으면 경우로 에러 메시지를 출력해줍니다. 

- ### cd [path]
현재 디렉토리(currentworkingdirectory)를 변경 하는 명령어입니다. 전역변수인 sd_cwd 는 current
workingdirectory 나타내는 구조체입니다. sd_cwd를 변경함 으로써 구현 할 수 있습니다.path 가
없으면 root 디렉토리가 current working directory가 됩니다. (mount 수행후 current working
directory). 에러 상황으로는 변경할 디렉토리가 존재 하지 않는 경우, 해당 경로가 디렉토리인가 아닌
경우 등이 있습니다. 

- ### touch path
새로운 빈(크기가 0) 파일을 만드는 명령어입니다.(빈 파일을 만드는 명령어 이므로 저장   할 데이터를
위한 블록은 할당 받을 필요가 없고, 새로운 파일의 i-node를 위한 블록만   할당 받으면 됩니다)
touch 명령어는 예제로 일부분이 구현되어 있는데 제한된 상황에서만 동작되는 형태로  구현되어
있습니다.(루트 디렉토리가 빈 상태에서만 동작 합니다. 이는 사용하지 않은 DISK2.img를
mount한 상태와 일치합니다) 이러한 이유는 디렉토리 엔트리를 위한 공간이나, i-node를 할당
받기 위해 블록을 할당 받을 번호를 실행 시간에 동적으로 탐색 하는 것이 아닌, 초기 루트
디렉토리 폴더만 존재 한다고 가정했을 때의 디렉토리 엔트리 위치와 블록 번호를 예측해서
구현했기 때문입니다. 비록 제한된 상황 에서만 동작되는 형태이지만 구현된 코드를 분석한다면
과제를 수행하는데 많은 도움이 될 것입니다. 실제로 디렉토리 엔트리의 위치, 할당, 비트맵을
이용한  블록 할당 등이 추가 된다면 완전한 구현이 될 수 있습니다. 에러 상황으로는 path가
이미 존재하는 경우, 디렉토리가 꽉차 더 이상 엔트리를 허용 못하는 경우, I-node를 할당 못한는
경우등이 있습니다.

- ### mkdir path
새로운 디렉토리를 생성 하는 명령어입니다.  i-node 구조체를 보면 현재 디렉토리에 대해 몇
개의 디렉토리 엔트리를 유지 하고 있는지에 대한 필드(변수)가 존재하지 않습니다. 이는 데이터
파일과 같은 형태의 i-node를 사용하기 때문인데, 데이터 파일에서 실제 용량을 나타내는 sfi_size
필드를 활용 할 수 있습니다. 본 과제에서는 디렉토리 엔트리가 추가 될 때마다 sfi_size의 값을
sizeof(struct sfs_dir) 만큼 증가시킴으로써 실제 몇 개의 엔트리가 사용 중인지 판단하도록
하겠습니다. mkdir을 통해 새로운 디렉토리를 생성 한 경우 새 디렉토리에 대해 .(자신)과 ..(부모)
디렉토리 엔트리를 추가해 주어야 합니다. 또한 할당 받은 디렉토리 블락의 모든 엔트리는
SFS_NOINO로 초기화 시키줍니다. 에러 상황으로 path가 이미 있는 경우(같은 이름의 파일이나
디렉토리), 할당 받을 디렉토리 엔트리가 없는 경우, 할당한 블락이 없는 경우 등입니다. 

- ### rmdir path
기존에 존재하는 디렉토리를 삭제 하는 명령어입니다. 해당 디렉토리의 이름(path)과
I-node번호를 저장하고 있던 부모 디렉토리의 디렉토리 엔트리의 내용은 지워지지만 차후의
재활용을 위하여 남겨 둡니다. 이 경우 해당 엔트리에 대해 i-node 번호로 SFS_NOINO를
사용합니다. 또 부모 디렉토리의 I-node의 sfi_size도 struct sfs_dir 사이즈만큼 줄어 들어야
합니다. 실제 할당 받은 디렉토리 블록에서 사용하는 디렉토리 엔트리의 수는 sfi_size를 struct
sfs_dir 사이즈로 나누어 알아낼 수 있습니다. 내용이 지워진 디렉토리의 엔트리도 나중에 재사용
될 때까지 그대로 유지하기 때문에 할당되어 있는 디렉토리의 엔트리 수는 항상
sfi_size/sizeof(struct sfs_dir) 보다 같거나 크게 됩니다. 하나의 데이터 블락에 있던 모든
디렉토리 엔트리가 제거되어도 해당 데이터 블락을 free 할 필요는 없습니다. 에러 상황으로는
path가 없는경우, 해당 경로가 디렉토리가 아닌 경우, 디렉토리가 안 비어 있는 경우 등이
있습니다. 

- ### mv path1 path2
파일 또는 디렉토리 path1의 이름을 path2의 이름으로 바꾸어 주는 명령어입니다. 실제 쉐에서
사용하는 mv와 달리 이름만 바꾸어 주는 기능만 구현 합니다. 결국 path1의 디렉토리 엔트리에서
이름을 바꾸어 주는 명령어입니다. 에러 상황으로 path1 이 존재하지 않는 경우와 path2 가 이미
존재하는 경우를 처리 해주어야 합니다.

- ### rm path
기존에 존재하는 데이터 파일을 삭제 하는 명령어입니다. 이 명령어는 rmdir과 비슷하게 구현 될
수 있습니다(해당 파일에 대한 디렉토리 엔트리의 재활용등 포함). sfi_direct[]와 sfi_indirect를
확인하여 할당된 모든 데이터 블락을 릴리즈해야 합니다. 그리고 할당된 I-node 블락도
릴리즈해야 합니다. 에러 상황으로는 path가 실제로 존재하는지, 해당 경로가 실제 데이터
파일인지에 대해서 검사해야 합니다. 

- ### cpin local_path path
cpin은 호스트 PC(실제 머신)의 파일 시스템에 존재하는 파일(path)을 SFS의 새로운
파일(local_path)로 복사하는 명령어입니다. 파일을 복사하는 경우 direct blocks 외에 indirect
block(single indirect pointer) 또한 고려하여 구현하셔야 합니다.(쓰려는 파일 용량이 커 direct
blocks에 모두 저장하지 못한다면 indirect block에 저장하는 형태로 구현 해야 합니다). 에러
상황으로는 path 파일이 없는 경우,local_path 파일이 이미 존재하는 경우,local_path 파일을 만들 수
없는 경우 (디렉토리가 꽉 찬 경우,i-node를 할당 못 받는 경우, 데이터 블락을 할당 못 받는 경우),
path 파일의 사이즈가 SFS 가 허용하는 파일의 사이즈를 넘어가는 경우 등입니다. 참고로 디스크가 꽉
차서 파일을 다 복사 못해도 가능한 부분까지 복사합니다.

- ### cpout local_path path
cpout은 SFS에 존재하는 파일(local_path)을 호스트 PC 파일 시스템의 path 파일로 복사 하는
명령어입니다. local_path 파일의 크기에 따라 sfi_direct[] 와 sfi_indirect에 설정된 모든 데이터
블락의 데이터를 path 파일로 복사 하여야 합니다. 에러 상황으로는 local_path 파일이 없는 경우, path 파일이 이미 존재하는 경우등 path 파일을 생성 못하는 경우입니다. 

